<!DOCTYPE html>
<html dir="“rtl”">
  <head>
    <meta charset="“UTF-8”" />
    <title>تصور الرسم البياني باستخدام Tkinter</title>
    <style>
      * {
        direction: rtl;
      }
    </style>
  </head>

  <body>
    <h1>تصور الرسم البياني باستخدام Tkinter</h1>

    <p>
      يوفر هذا البرنامج النصي Python تمثيلًا مرئيًا للرسم البياني ، مستفيدًا من
      مكتبة Tkinter لواجهة المستخدم الرسومية.
    </p>

    <h2>الميزات:</h2>

    <ul>
      <li>
        <strong>تصور الرسوم البيانية:</strong> يعرض بيانات الرسم البياني المخزنة
        في ملف JSON.
      </li>
      <li>
        <strong>تنسيق قائمة الجوار:</strong> يدعم الرسوم البيانية الممثلة
        باستخدام تنسيق قائمة الجوار.
      </li>
      <li>
        <strong>تمييز العقد:</strong> يسلط الضوء على العقد بشكل اختياري بناءً
        على المسافات المحددة من رأس مصدر.
      </li>
      <li>
        <strong>معالجة الأخطاء:</strong> تتضمن معالجة قوية للأخطاء لإدارة
        المدخلات غير الصالحة أو أخطاء الملفات بأمان.
      </li>
      <li>
        <strong>تسجيل مفصل:</strong> يسجل الأحداث الرئيسية والمشكلات المحتملة في
        ملف لتصحيح الأخطاء والمراقبة.
      </li>
    </ul>

    <h2>التثبيت:</h2>

    <ol>
      <li>
        <strong>Python و Tkinter:</strong> تأكد من تثبيت Python على نظامك. عادةً
        ما يتم تضمين Tkinter في توزيعات Python القياسية.
      </li>
      <li>
        <strong>الحزم المطلوبة:</strong> لا توجد حزم خارجية مطلوبة تتجاوز مكتبة
        Python القياسية.
      </li>
    </ol>

    <h2>الاستخدام:</h2>

    <ol>
      <li>
        <strong>جهّز بيانات الرسم البياني:</strong>
        <ul>
          <li>
            أنشئ ملف JSON يمثل الرسم البياني الخاص بك كقائمة مجاورة. على سبيل
            المثال:
          </li>
        </ul>
        <pre><code> { “A”: {“B”: 4, “C”: 2}, “B”: {“C”: 1, “D”: 5}, “C”: {“D”: 8, “E”: 10}, “D”: {“E”: 2, “F”: 6}, “E”: {“F”: 3}, “F”: {} } </code></pre>
        <ul>
          <li>
            في هذا التنسيق ، يمثل كل مفتاح في كائن JSON رأسًا في الرسم البياني.
          </li>
          <li>
            القيمة المقابلة هي قاموس آخر يمثل الرؤوس المجاورة وأوزان الحواف.
          </li>
        </ul>
      </li>
      <li>
        <strong>تشغيل البرنامج النصي:</strong>
        <ul>
          <li>
            استبدل <code>“graph.json”</code> في كتلة
            <code>if name == “main”:</code> بالمسار الفعلي لملف الرسوم البيانية
            JSON.
          </li>
          <li>
            قم بتشغيل البرنامج النصي باستخدام
            <code>python graph_visualization.py</code> (أو طريقتك المفضلة لتنفيذ
            برامج Python النصية).
          </li>
          <li>ستظهر نافذة Tkinter ، تعرض الرسم البياني المرئي.</li>
        </ul>
      </li>
    </ol>

    <h2>شرح الكود:</h2>

    <p>يتم تنظيم الكود في وظائف من أجل الوضوح وإمكانية إعادة الاستخدام:</p>

    <h3>1. <code>visualize_graph(graph_filepath, distances=None)</code>:</h3>

    <p>
      هذه الوظيفة مسؤولة عن تحميل بيانات الرسم البياني ، وإنشاء التصور ، ومعالجة
      الأخطاء.
    </p>

    <pre><code> def visualize_graph(graph_filepath, distances=None): “”" يعرض رسمًا بيانيًا من ملف JSON باستخدام Tkinter Canvas.

Args:
    graph_filepath (str): المسار إلى ملف JSON الذي يحتوي على بيانات الرسم البياني.
                          يجب أن يمثل JSON الرسم البياني كقائمة مجاورة.
    distances (dict, optional): قاموس يرسم الرؤوس على أقصر مسافاتها من رأس المصدر.
                                إذا تم توفيره ، فسوف تعكس ألوان العقد المسافات.

Raises:
    FileNotFoundError: إذا لم يتم العثور على ملف الرسم البياني المحدد.
    json.JSONDecodeError: إذا لم يكن ملف JSON بتنسيق JSON صالحًا أو ليس له التنسيق الصحيح.
    TypeError: إذا تم توفير `distances` ولم يكن قاموسًا.
    ValueError: إذا لم يتم العثور على أي رأس في `distances` في الرسم البياني.
    Exception: لأي أخطاء أخرى غير متوقعة أثناء التصور.
"""

# ... (تنفيذ الكود - انظر الأقسام التالية للحصول على تفسيرات)
</code></pre>

    <ul>
      <li>
        <strong>الحجج:</strong>
        <ul>
          <li>
            <code>graph_filepath (str)</code>: المسار إلى ملف JSON الذي يحتوي
            على بيانات الرسم البياني.
          </li>
          <li>
            <code>distances (dict, optional)</code>: قاموس اختياري حيث تكون
            المفاتيح رؤوسًا ، والقيم هي مسافاتها من رأس المصدر (تستخدم لتمييز
            العقد).
          </li>
        </ul>
      </li>
      <li>
        <strong>معالجة الأخطاء:</strong>
        <ul>
          <li>
            يستخدم كتل <code>try…except</code> للتعامل مع الأخطاء المحتملة أثناء
            تحميل الملفات (<code>FileNotFoundError</code> و
            <code>json.JSONDecodeError</code>) ، والتحقق من صحة نوع البيانات
            (<code>TypeError</code>) ، والأخطاء غير المتوقعة أثناء التصور
            (<code>Exception</code>).
          </li>
          <li>
            يسجل رسائل الخطأ باستخدام وحدة <code>logging</code> لتوفير معلومات
            تصحيح الأخطاء.
          </li>
        </ul>
      </li>
    </ul>

    <h4>1.1 تحميل بيانات الرسم البياني</h4>

    <pre><code> try: # تحميل بيانات الرسم البياني من ملف JSON with open(graph_filepath, “r”) as file: graph = json.load(file) except FileNotFoundError: logging.error(f"لم يتم العثور على ملف الرسم البياني: {graph_filepath}“) raise except json.JSONDecodeError: logging.error(f"تنسيق JSON غير صالح في الملف: {graph_filepath}”) raise </code></pre>

    <ul>
      <li>يحاول هذا القسم تحميل بيانات الرسم البياني من ملف JSON المحدد.</li>
      <li>
        يستخدم كتلة <code>with open(…)</code> لضمان إغلاق الملف بشكل صحيح ، حتى
        في حالة حدوث أخطاء.
      </li>
      <li>
        تقوم دالة <code>json.load(file)</code> بتحليل بيانات JSON إلى قاموس
        Python.
      </li>
      <li>
        تتم معالجة الأخطاء في مكانها للقبض على <code>FileNotFoundError</code> و
        <code>json.JSONDecodeError</code>. إذا تم اكتشافها ، يتم تسجيل الأخطاء ،
        وإعادة طرح الاستثناءات.
      </li>
    </ul>

    <h4>1.2 التحقق من صحة الإدخال</h4>

    <pre><code> # معالجة الأخطاء: التحقق من صحة الإدخال if not isinstance(graph, dict): logging.error(“تم توفير نوع رسم بياني غير صالح. يجب أن يكون كائنًا يشبه القاموس.”) raise TypeError(“يجب أن يكون الرسم البياني كائنًا يشبه القاموس.”) if distances is not None: if not isinstance(distances, dict): logging.error(“يجب توفير المسافات كقاموس.”) raise TypeError(“يجب أن تكون المسافات قاموسًا.”) for vertex in distances: if vertex not in graph: logging.error(f"لم يتم العثور على الرأس {vertex} في ‘المسافات’ في الرسم البياني.“) raise ValueError( f"لم يتم العثور على الرأس {vertex} في ‘المسافات’ في الرسم البياني.” ) </code></pre>

    <ul>
      <li>
        قبل المتابعة ، يتحقق الكود من صحة بيانات الإدخال:
        <ul>
          <li>
            <strong>التحقق من نوع الرسم البياني:</strong> يتحقق مما إذا كان
            <code>graph</code> المحمّل هو كائن يشبه القاموس (وهو متوقع لتمثيل
            قائمة الجوار).
          </li>
          <li>
            <strong>التحقق من نوع واتساق المسافات:</strong> إذا تم توفير
            <code>distances</code>:
            <ul>
              <li>يتحقق مما إذا كان قاموسًا.</li>
              <li>
                يتحقق من وجود كل رأس في قاموس <code>distances</code> في
                <code>graph</code> المحمّل.
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    <h4>1.3 إعداد Tkinter</h4>

    <pre><code> window = tk.Tk() window.title(“تصور الرسم البياني”)

canvas_width = 800
canvas_height = 600
canvas = tk.Canvas(window, width=canvas_width, height=canvas_height, bg="white")
canvas.pack()
</code></pre>

    <ul>
      <li>
        <strong>إنشاء النافذة:</strong> يتم إنشاء نافذة رئيسية
        (<code>window</code>) باستخدام <code>tk.Tk()</code> ، ويتم تعيين
        عنوانها.
      </li>
      <li>
        <strong>إعداد Canvas:</strong> يتم إنشاء عنصر واجهة مستخدم
        <code>tk.Canvas</code>. يعمل Canvas كمنطقة رسم لتصور الرسم البياني. يتم
        تهيئة بعرض محدد وارتفاع ولون خلفية أبيض.
      </li>
    </ul>

    <h4>1.4 رسم العقد والحواف</h4>

    <pre><code> node_radius = 20 node_positions = {} # تخزين مواضع العقد لرسم الحواف

# ... (الدالتان المساعدتان draw_node و get_node_color)

# --- منطق رسم العقد والحواف ---
try:
    num_vertices = len(graph)
    angle_increment = 2 * math.pi / num_vertices

    # حساب مواضع العقد قبل الرسم
    for i, vertex in enumerate(graph):
        angle = i * angle_increment
        x = canvas_width / 2 + 200 * math.cos(angle)
        y = canvas_height / 2 + 200 * math.sin(angle)
        node_positions[vertex] = (x, y)  # تخزين الموضع فقط

    # رسم العقد والحواف
    for u in graph:
        draw_node(u, node_positions[u][0], node_positions[u][1])
        for v, weight in graph[u].items():
            if v in node_positions:
                x1, y1 = node_positions[u][:2]  # فك حزم x و y فقط
                x2, y2 = node_positions[v][:2]  # فك حزم x و y فقط
                canvas.create_line(x1, y1, x2, y2)
                canvas.create_text(
                    (x1 + x2) / 2,
                    (y1 + y2) / 2,
                    text=str(weight),
                    font=("Arial", 10),
                )
                logging.debug(f"تم رسم الحافة: ({u}, {v}), الوزن: {weight}")

    # تمييز العقد بناءً على المسافات (إذا تم توفيرها)
    if distances:
        max_distance = max(distances.values())
        for vertex, dist in distances.items():
            if vertex in node_positions:  # تأكد من وجود العقدة في الرسم البياني
                x, y, node_id = node_positions[vertex]
                color = get_node_color(dist, max_distance)
                canvas.itemconfig(node_id, fill=color)

except Exception as e:
    logging.error(f"حدث خطأ أثناء التصور: {e}")

window.mainloop()
</code></pre>

    <ul>
      <li>
        <strong>تحديد موضع العقد:</strong>
        <ul>
          <li>يحسب الكود مواضع العقد لترتيبها في مخطط دائري على Canvas.</li>
          <li>
            يستخدم حساب المثلثات (<code>math.cos</code> و <code>math.sin</code>)
            لتحديد إحداثيات <code>(x, y)</code> لكل عقدة على محيط الدائرة.
          </li>
        </ul>
      </li>
      <li>
        <strong>رسم العقد والحواف:</strong>
        <ul>
          <li>يتكرر من خلال الرؤوس والحواف للرسم البياني.</li>
          <li>
            يتم استدعاء دالة <code>draw_node</code> المساعدة (الموضحة أدناه)
            لرسم كل عقدة على Canvas في موضعها المحسوب.
          </li>
          <li>
            يتم رسم الحواف كخطوط بين العقد باستخدام
            <code>canvas.create_line</code>.
          </li>
          <li>
            يتم عرض أوزان الحواف كتسميات نصية بالقرب من منتصف كل حافة باستخدام
            <code>canvas.create_text</code>.
          </li>
        </ul>
      </li>
      <li>
        <strong>تمييز العقد (اختياري):</strong>
        <ul>
          <li>
            إذا تم توفير قاموس <code>distances</code> ، فسيتم تمييز العقد بناءً
            على مسافاتها.
          </li>
          <li>
            تقوم دالة <code>get_node_color</code> المساعدة (الموضحة أدناه) بحساب
            لون على طول تدرج (من الأخضر إلى الأحمر) بناءً على المسافة الطبيعية
            لكل عقدة.
          </li>
        </ul>
      </li>
    </ul>

    <strong>الدوال المساعدة:</strong>

    <ul>
      <li>
        <strong><code>draw_node(vertex, x, y)</code>:</strong> يرسم عقدة واحدة
        (ممثلة كدائرة) مع تسميتها على Canvas. يستخدم
        <code>canvas.create_oval</code> لرسم الدائرة و
        <code>canvas.create_text</code> لوضع تسمية الرأس في مركزها.
      </li>
      <li>
        <strong><code>get_node_color(distance, max_distance)</code>:</strong>
        يحسب لونًا على طول تدرج من الأخضر إلى الأحمر بناءً على
        <code>distance</code> المحددة و <code>max_distance</code>. يستخدم هذا
        لتمثيل المسافات النسبية للعقد من رأس المصدر بشكل مرئي (إذا تم توفير
        معلومات المسافة).
      </li>
    </ul>

    <h2>التسجيل:</h2>

    <p>
      يستخدم هذا البرنامج النصي وحدة <code>logging</code> لتسجيل الرسائل
      الإعلامية أثناء تنفيذه. هذا مفيد لـ:
    </p>

    <ul>
      <li>
        <strong>تصحيح الأخطاء:</strong> تحديد وحل أي أخطاء أو مشكلات بسرعة.
      </li>
      <li><strong>المراقبة:</strong> فهم تدفق سلوك البرنامج النصي وسلوكه.</li>
    </ul>

    <p>
      يمكنك تخصيص مستوى التسجيل والتنسيق في استدعاء
      <code>logging.basicConfig()</code>.
    </p>

    <h2>الخلاصة:</h2>

    <p>
      توفر هذه الوثائق نظرة عامة شاملة على برنامج Python النصي المقدم لتصور
      الرسم البياني. من خلال دعمه لتحميل بيانات الرسم البياني من ملفات JSON ،
      وتمييز العقد الاختياري بناءً على المسافات ، ومعالجة الأخطاء ، وتسجيل
      المعلومات ، يعد هذا البرنامج النصي أداة مفيدة لاستكشاف هياكل الرسوم
      البيانية وتقديمها بشكل مرئي. تذكر تخصيص الكود وتجربة بيانات الرسم البياني
      الخاصة بك لحالات الاستخدام المختلفة.
    </p>
  </body>
</html>
